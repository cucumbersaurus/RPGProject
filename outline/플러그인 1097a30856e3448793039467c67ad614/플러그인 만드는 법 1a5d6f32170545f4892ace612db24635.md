# 플러그인 만드는 법

대충 인텔리제이 아이디어 커뮤니티 버젼과 거기에 마크 플러그인/모드 용 인텔리제이 플러그인을 설치하고 프로젝트 만들고 깃허브 연결은 다들 알아서 하시고

아무튼

그 자본 플러그인의 메인 클래스를 보면

```java
package cucumbersaurus.zabon;

import cucumbersaurus.zabon.commands.GetPlayerLocation;
import cucumbersaurus.zabon.commands.GuiCommands;
import cucumbersaurus.zabon.commands.Wasans;
import cucumbersaurus.zabon.commands.effectmenu.EffectCommands;
import cucumbersaurus.zabon.commands.fileTest.FileTest;
import cucumbersaurus.zabon.commands.fileTest.FileTestCommand;
import cucumbersaurus.zabon.eventListener.GuiListener;
import cucumbersaurus.zabon.eventListener.JoinEventListener;
import cucumbersaurus.zabon.eventListener.QuitEventListener;
import cucumbersaurus.zabon.zabon.ZabonGuiOpenCommand;
import cucumbersaurus.zabon.zabon.bank.BankGuiOpenCommand;
import cucumbersaurus.zabon.zabon.tradeItem.TradeItemList;
import cucumbersaurus.zabon.zabon.tradeItem.addTradeIttem.AddTradeItemGuiCommand;
import cucumbersaurus.zabon.zabon.tradeItem.tradeGui.TradeGuiCommand;
import org.bukkit.plugin.java.JavaPlugin;

import java.util.Objects;

public final class Zabon extends JavaPlugin {

    @Override
    public void onEnable() {
        // Plugin startup logic
        getLogger().info("plugin loading");

        getCommands();
        registerEvents();
        //loadFile();
        TradeItemList.makeFile();
        TradeItemList.FileToList();
        TradeItemList.setPlugin(this);
        TradeItemList.ListToFile();

        getLogger().info("plugin enabled");
    }

    @Override
    public void onDisable() {
        // Plugin shutdown logic
        //saveFile();
        getLogger().info("plugin disabled");
    }

    private void getCommands(){
        Objects.requireNonNull(getCommand("wasans")).setExecutor(new Wasans());
        Objects.requireNonNull(getCommand("guitest")).setExecutor(new GuiCommands());
        Objects.requireNonNull(getCommand("playerlocation")).setExecutor(new GetPlayerLocation());
        Objects.requireNonNull(getCommand("effectmenu")).setExecutor(new EffectCommands());
        Objects.requireNonNull(getCommand("zabon")).setExecutor(new ZabonGuiOpenCommand());
        Objects.requireNonNull(getCommand("bank")).setExecutor(new BankGuiOpenCommand());
        Objects.requireNonNull(getCommand("add")).setExecutor(new FileTestCommand());
        Objects.requireNonNull(getCommand("trade")).setExecutor(new TradeGuiCommand());
        Objects.requireNonNull(getCommand("additem")).setExecutor(new AddTradeItemGuiCommand());
    }

    private void registerEvents(){
        getServer().getPluginManager().registerEvents(new JoinEventListener(), this);
        getServer().getPluginManager().registerEvents(new QuitEventListener(), this);
        getServer().getPluginManager().registerEvents(new GuiListener(), this);
    }

    private void loadFile(){
        FileTest.setPlugin(this);
        FileTest.makeFile(FileTest.f);
        FileTest.mapToFile(FileTest.f, FileTestCommand.map);

    }

    private void saveFile(){
        FileTest.fileToMap(FileTest.f, FileTestCommand.map);
    }

}
```

대충 위에 임포트는 어떤 파일 끌어다 쓸건지고 어짜피 자동으로 생겨서 중요하지 않고

패키지는 다른 클래스에 임포트 될때 쓸 이름

보통 폴더명.폴더명 으로 임포트 될때는 폴더명.폴더명....파일 이름

근데 여기서 자바 자료형 부터 설명하고 시작하기는 빡세니까 천천히 알려줄거고

public final class Zabon extends JavaPlugin

이라고 생긴 부분이 클래스 선언인데

public은 어떤 클래스든 이 클래스를 사용 가능하다는 뜻이고

final 은 상수(?)의 느낌이라 안에 든 값을 수정 불가한데 아마 메모리 주소값일거고(중요하진 않음)

class는 클래스를 만든다는 소리이고

뒤에 자본은 대충 클래스 이름

extend 는 extend 뒤의 클래스를 상속 받아서 이 클래스를 만들겠다는 뜻

참고로 저 JavaPlugin 클래스는 paper api에 선언되어 있음(대충 페이퍼.jar 파일에 있다는 뜻)

뒤에 중괄호까지 열리면 그 중괄호 안쪽은 클래스의 속성을 정의하는 부분이 되는거임

 @Override
    public void onEnable()

라고 생긴 부분이 있는데

여기서 @Overried 라는 부분은 →

아까 JavaPlugin에서 이 클래스가 상속 받았다고 했지

그리고 JavaPlugin에도 여러 함수(메서드) 가 있겠지

그 중에 자식 클래스에서 부모 클래스에 정의된 함수를 다시 정의하고 싶을때

저걸 붙여주면 함수를 덮어씌우는게 가능

상속 관련은 복잡하니 자세히는 나중에 설명하던가 하고 궁금하면 알아서 찾아보시고

그래서 저 @Override  의 기능은 아래 onEnable 이라는 함수가 JavaPlugin을 상속받아서 거기에 있는걸 써도 되지만 맘에 안드니까 내맘대로 상속받은걸 내용을 바꿔서 쓰겠다는 뜻

가독성을 위해 탭 한번 눌러주고

public 인 부분은 이 클래스 바깥에서 다른 클래스가 이 함수를 사용 가능 하게 한다는 소리고

void는 이 함수가 작업을 끝내고 함수를 부른 쪽에 값을 반환하지 않는다는 뜻임

원래는 반환되는 값의 자료형을 써야 하지만 없기 때문에 void를 쓰는거임

참고로 함수의 정의는 대충

(공개 범위) (반환 자료형) (이름) ‘(’ (매개변수 1), (매개변수2), .... ‘)’ 

{...\

대충 코드

...}

이런 느낌이니까 알아 두셈

결론적으로 onEnable 이라는 함수는 플러그인이 시작될때 사용된다고 사용되는 함수임

이라고 공식 자료에 써있음

함수에 코드 부분을 보면 

{
        // Plugin startup logic
        getLogger().info("plugin loading");

        getCommands();
        registerEvents();
        //loadFile();
        TradeItemList.makeFile();
        TradeItemList.FileToList();
        TradeItemList.setPlugin(this);
        TradeItemList.ListToFile();

        getLogger().info("plugin enabled");
    }

이런 모양인데

//이런 식으로

‘/’ 를 두개 붙여주면 주석 처리로

코드로 인식하지 않으니

설명 같은걸 쓸 수 있음

그리고 

/* 이와 

같이 

여러 

줄로 

쓰고

싶으면*/   

슬래시 별과 별 슬래시 사이에 넣으면 됨

~~참 쉽죠?~~
자 이걸 보면

getLogger().info("plugin loading");

getLogger() 라는 함수를 호출을 했지

그러면 그 반환 값이 있지

getLogger().info("plugin loading");

함수 대신에 그 반환값을 넣는다 생각해봐

(반환값).info("plugin loading");

이 점의 뜻은 아는 놈은 알겠지만

클래스 내부에서 생성된 함수나 변수에 접근하는 점임

getLogger() 라는 함수의 반환 클래스에서

info() 라는 함수를 찾아서 “plugin loading” 을 매개 변수로 넘겨서 함수를 호출하라는 뜻임

결국 저 코드가 뭐하는거냐면

콘솔창에 플러그인이 처음 로딩될때 로그를 찍으라는 거임

로그는 info() 에 매개변수로 넣은 문장으로 찍힘

대충 아래는 플러그인에 명령어 적용이랑

이벤트 핸들러 적용이나 이런거 하는(이런거 명령어 구현하고 여기에 적용 안하면 작동 안함)

간단한 코드라

아래 함수에서 대충 형식 한번씩 보시고

참고로 onDisable은 플러그인 언로드 될때(서버 꺼질때)

사용됨 이것도 필수임

추가할만한 내용 써주면 추가해줌